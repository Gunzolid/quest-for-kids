import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/task_entity.dart';
import '../../domain/repositories/task_repository.dart';
import '../../../../core/services/notification_service.dart';
import '../../data/repositories/task_repository_impl.dart';
import '../../../notifications/domain/entities/notification_entity.dart';
import '../../../notifications/presentation/providers/notification_providers.dart';

// --- Dependencies ---
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

// --- Repository Provider ---
final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepositoryImpl(ref.watch(firestoreProvider));
});

// --- Logic / Controller ---
class TaskController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> createTask({
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    DateTime? startTime,
    DateTime? endTime,
    String? imageUrl,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: '', // Generated by repo
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: TaskStatus.pending,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
        imageUrl: imageUrl,
      );
      await ref
          .read(taskRepositoryProvider)
          .createTask(task, parentId, childId);

      // Schedule Notification
      if (startTime != null) {
        await ref
            .read(notificationServiceProvider)
            .scheduleNotification(
              id: task.id.hashCode,
              title: 'Mission Start: $title',
              body: 'It\'s time to start your mission!',
              scheduledDate: startTime,
            );
      }
    });
  }

  Future<void> updateTask({
    required String taskId,
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    required TaskStatus status,
    DateTime? startTime,
    DateTime? endTime,
    String? imageUrl,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: taskId,
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: status,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
        imageUrl: imageUrl,
      );
      await ref
          .read(taskRepositoryProvider)
          .updateTask(task, parentId, childId);

      // Reschedule Notification
      final notifService = ref.read(notificationServiceProvider);
      await notifService.cancelNotification(taskId.hashCode);
      if (startTime != null) {
        await notifService.scheduleNotification(
          id: taskId.hashCode,
          title: 'Mission Update: $title',
          body: 'Your mission has been updated!',
          scheduledDate: startTime,
        );
      }
    });
  }

  Future<void> markTaskAsCompleted({
    required String parentId,
    required String childId,
    required String taskId,
    required int points,
    required String childName,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      // Auto-approve: Mark as approved and award points immediately
      await ref
          .read(taskRepositoryProvider)
          .approveTask(parentId, childId, taskId, points);
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);

      // --- Send Parent Notification ---
      // using the passed childName
      final task =
          (await ref
                  .read(taskRepositoryProvider)
                  .getTasksForChild(parentId, childId)
                  .first)
              .firstWhere((t) => t.id == taskId);

      final notification = NotificationEntity(
        id: '', // Generated by Repo
        title: '$childName completed a mission!',
        message:
            '${task.title} has been completed by $childName! (+ $points KP)',
        timestamp: DateTime.now(),
        isRead: false,
        type: NotificationType.taskCompleted,
        childId: childId,
        relatedId: taskId,
      );

      await ref
          .read(notificationRepositoryProvider)
          .sendNotification(parentId, notification);
    });
  }

  Future<void> approveTask({
    required String parentId,
    required String childId,
    required String taskId,
    required int points,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .approveTask(parentId, childId, taskId, points);
    });
  }

  Future<void> deleteTask(
    String parentId,
    String childId,
    String taskId,
  ) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .deleteTask(parentId, childId, taskId);
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);
    });
  }

  Future<void> clearHistory(String parentId, String childId) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .deleteCompletedTasks(parentId, childId);
    });
  }
}

final taskControllerProvider = AsyncNotifierProvider<TaskController, void>(
  TaskController.new,
);

// --- Data Streams ---
// We need a family provider because we need parentId and childId to fetch tasks
final tasksStreamProvider =
    StreamProvider.family<
      List<TaskEntity>,
      ({String parentId, String childId})
    >((ref, args) {
      return ref
          .watch(taskRepositoryProvider)
          .getTasksForChild(args.parentId, args.childId);
    });
