import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/task_entity.dart';
import '../../domain/repositories/task_repository.dart';
import '../../../../core/services/notification_service.dart';
import '../../data/repositories/task_repository_impl.dart';
import '../../../notifications/domain/entities/notification_entity.dart';
import '../../../notifications/presentation/providers/notification_providers.dart';

// --- Dependencies ---
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

// --- Repository Provider ---
final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepositoryImpl(ref.watch(firestoreProvider));
});

// --- Logic / Controller ---
class TaskController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> createTask({
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    DateTime? startTime,
    DateTime? endTime,
    String? imageUrl,
    int? reminderMinutes,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: '', // Generated by repo
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: TaskStatus.pending,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
        imageUrl: imageUrl,
        reminderMinutes: reminderMinutes,
      );
      await ref
          .read(taskRepositoryProvider)
          .createTask(task, parentId, childId);

      final notifService = ref.read(notificationServiceProvider);

      // Schedule Start Notification
      if (startTime != null) {
        await notifService.scheduleNotification(
          id: task.id.hashCode,
          title: 'Mission Start: $title',
          body: 'It\'s time to start your mission!',
          scheduledDate: startTime,
        );
      }

      // Schedule Due Soon Notification
      if (endTime != null && reminderMinutes != null) {
        final reminderTime = endTime.subtract(
          Duration(minutes: reminderMinutes),
        );
        if (reminderTime.isAfter(DateTime.now())) {
          await notifService.scheduleNotification(
            id: task.id.hashCode + 1,
            title: 'Hurry up! $title is due soon!',
            body:
                'You have $reminderMinutes minutes left to complete this mission.',
            scheduledDate: reminderTime,
          );
        }
      }
    });
  }

  Future<void> updateTask({
    required String taskId,
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    required TaskStatus status,
    DateTime? startTime,
    DateTime? endTime,
    String? imageUrl,
    int? reminderMinutes,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: taskId,
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: status,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
        imageUrl: imageUrl,
        reminderMinutes: reminderMinutes,
      );
      await ref
          .read(taskRepositoryProvider)
          .updateTask(task, parentId, childId);

      // Reschedule Notification
      final notifService = ref.read(notificationServiceProvider);
      await notifService.cancelNotification(taskId.hashCode);

      // Start Time Notification
      if (startTime != null) {
        await notifService.scheduleNotification(
          id: taskId.hashCode,
          title: 'Mission Update: $title',
          body: 'Your mission has been updated!',
          scheduledDate: startTime,
        );
      }

      // Due Soon Notification
      // Use different ID: taskId.hashCode + 1
      await notifService.cancelNotification(taskId.hashCode + 1);
      if (endTime != null && reminderMinutes != null) {
        final reminderTime = endTime.subtract(
          Duration(minutes: reminderMinutes),
        );
        if (reminderTime.isAfter(DateTime.now())) {
          await notifService.scheduleNotification(
            id: taskId.hashCode + 1,
            title: 'Hurry up! $title is due soon!',
            body:
                'You have $reminderMinutes minutes left to complete this mission.',
            scheduledDate: reminderTime,
          );
        }
      }
    });
  }

  Future<void> markTaskAsCompleted({
    required String parentId,
    required String childId,
    required String taskId,
    required int points,
    required String childName,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      // Auto-approve: Mark as approved and award points immediately
      await ref
          .read(taskRepositoryProvider)
          .approveTask(parentId, childId, taskId, points);
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);

      // --- Send Parent Notification ---
      // using the passed childName
      final task =
          (await ref
                  .read(taskRepositoryProvider)
                  .getTasksForChild(parentId, childId)
                  .first)
              .firstWhere((t) => t.id == taskId);

      final notification = NotificationEntity(
        id: '', // Generated by Repo
        title: '$childName completed a mission!',
        message:
            '${task.title} has been completed by $childName! (+ $points KP)',
        timestamp: DateTime.now(),
        isRead: false,
        type: NotificationType.taskCompleted,
        childId: childId,
        relatedId: taskId,
      );

      await ref
          .read(notificationRepositoryProvider)
          .sendNotification(parentId, notification);
    });
  }

  Future<void> approveTask({
    required String parentId,
    required String childId,
    required String taskId,
    required int points,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .approveTask(parentId, childId, taskId, points);
    });
  }

  Future<void> deleteTask(
    String parentId,
    String childId,
    String taskId,
  ) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .deleteTask(parentId, childId, taskId);
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);
    });
  }

  Future<void> clearHistory(String parentId, String childId) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .deleteCompletedTasks(parentId, childId);
    });
  }

  Future<void> markTaskAsLate({
    required String parentId,
    required String childId,
    required String taskId,
  }) async {
    // state = const AsyncValue.loading(); // Avoid full loading state for background updates
    state = await AsyncValue.guard(() async {
      final task =
          (await ref
                  .read(taskRepositoryProvider)
                  .getTasksForChild(parentId, childId)
                  .first)
              .firstWhere((t) => t.id == taskId);

      final updatedTask = TaskEntity(
        id: task.id,
        title: task.title,
        description: task.description,
        points: task.points,
        isRecurring: task.isRecurring,
        status: TaskStatus.late,
        assignedToId: task.assignedToId,
        startTime: task.startTime,
        endTime: task.endTime,
        imageUrl: task.imageUrl,
      );

      await ref
          .read(taskRepositoryProvider)
          .updateTask(updatedTask, parentId, childId);
    });
  }

  Future<void> setTaskReminder({
    required String parentId,
    required String childId,
    required String taskId,
    required int? reminderMinutes,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task =
          (await ref
                  .read(taskRepositoryProvider)
                  .getTasksForChild(parentId, childId)
                  .first)
              .firstWhere((t) => t.id == taskId);

      final updatedTask = TaskEntity(
        id: task.id,
        title: task.title,
        description: task.description,
        points: task.points,
        isRecurring: task.isRecurring,
        status: task.status,
        assignedToId: task.assignedToId,
        startTime: task.startTime,
        endTime: task.endTime,
        imageUrl: task.imageUrl,
        reminderMinutes: reminderMinutes,
      );

      await ref
          .read(taskRepositoryProvider)
          .updateTask(updatedTask, parentId, childId);

      // Manage Notifications
      final notifService = ref.read(notificationServiceProvider);
      // Cancel existing Due Soon notification
      await notifService.cancelNotification(taskId.hashCode + 1);

      if (task.endTime != null && reminderMinutes != null) {
        final reminderTime = task.endTime!.subtract(
          Duration(minutes: reminderMinutes),
        );
        if (reminderTime.isAfter(DateTime.now())) {
          await notifService.scheduleNotification(
            id: taskId.hashCode + 1,
            title: 'Hurry up! ${task.title} is due soon!',
            body:
                'You have $reminderMinutes minutes left to complete this mission.',
            scheduledDate: reminderTime,
          );
        }
      }
    });
  }

  Future<void> checkOverdueTasks(
    List<TaskEntity> tasks,
    String parentId,
    String childId,
  ) async {
    final now = DateTime.now();
    for (final task in tasks) {
      if (task.status == TaskStatus.pending &&
          task.endTime != null &&
          task.endTime!.isBefore(now)) {
        await markTaskAsLate(
          parentId: parentId,
          childId: childId,
          taskId: task.id,
        );
      }
    }
  }
}

final taskControllerProvider = AsyncNotifierProvider<TaskController, void>(
  TaskController.new,
);

// --- Data Streams ---
// We need a family provider because we need parentId and childId to fetch tasks
final tasksStreamProvider =
    StreamProvider.family<
      List<TaskEntity>,
      ({String parentId, String childId})
    >((ref, args) {
      return ref
          .watch(taskRepositoryProvider)
          .getTasksForChild(args.parentId, args.childId);
    });
