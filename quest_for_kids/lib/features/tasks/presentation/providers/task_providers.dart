import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/task_entity.dart';
import '../../domain/repositories/task_repository.dart';
import '../../../../core/services/notification_service.dart';
import '../../data/repositories/task_repository_impl.dart';

// --- Dependencies ---
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

// --- Repository Provider ---
final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepositoryImpl(ref.watch(firestoreProvider));
});

// --- Logic / Controller ---
class TaskController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> createTask({
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    DateTime? startTime,
    DateTime? endTime,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: '', // Generated by repo
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: TaskStatus.pending,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
      );
      await ref
          .read(taskRepositoryProvider)
          .createTask(task, parentId, childId);

      // Schedule Notification
      if (startTime != null) {
        await ref.read(notificationServiceProvider).scheduleNotification(
              id: task.id.hashCode,
              title: 'Mission Start: $title',
              body: 'It\'s time to start your mission!',
              scheduledDate: startTime,
            );
      }
    });
  }

  Future<void> updateTask({
    required String taskId,
    required String title,
    required String description,
    required int points,
    required bool isRecurring,
    required String parentId,
    required String childId,
    required TaskStatus status,
    DateTime? startTime,
    DateTime? endTime,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final task = TaskEntity(
        id: taskId,
        title: title,
        description: description,
        points: points,
        isRecurring: isRecurring,
        status: status,
        assignedToId: childId,
        startTime: startTime,
        endTime: endTime,
      );
      await ref
          .read(taskRepositoryProvider)
          .updateTask(task, parentId, childId);

      // Reschedule Notification
      final notifService = ref.read(notificationServiceProvider);
      await notifService.cancelNotification(taskId.hashCode);
      if (startTime != null) {
        await notifService.scheduleNotification(
          id: taskId.hashCode,
          title: 'Mission Update: $title',
          body: 'Your mission has been updated!',
          scheduledDate: startTime,
        );
      }
    });
  }

  Future<void> markTaskAsCompleted({
    required String parentId,
    required String childId,
    required String taskId,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(taskRepositoryProvider).updateTaskStatus(
            parentId,
            childId,
            taskId,
            TaskStatus.completed,
          );
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);
    });
  }

  Future<void> approveTask({
    required String parentId,
    required String childId,
    required String taskId,
    required int points,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(taskRepositoryProvider).approveTask(
            parentId,
            childId,
            taskId,
            points,
          );
    });
  }

  Future<void> deleteTask(
      String parentId, String childId, String taskId) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref
          .read(taskRepositoryProvider)
          .deleteTask(parentId, childId, taskId);
      await ref
          .read(notificationServiceProvider)
          .cancelNotification(taskId.hashCode);
    });
  }
}

final taskControllerProvider =
    AsyncNotifierProvider<TaskController, void>(TaskController.new);

// --- Data Streams ---
// We need a family provider because we need parentId and childId to fetch tasks
final tasksStreamProvider = StreamProvider.family<List<TaskEntity>,
    ({String parentId, String childId})>((ref, args) {
  return ref
      .watch(taskRepositoryProvider)
      .getTasksForChild(args.parentId, args.childId);
});
